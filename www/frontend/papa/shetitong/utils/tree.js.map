{"version":3,"file":"tree.js","sources":["../../../../src/utils/tree.js"],"sourcesContent":["/**\n * 与树处理相关的函数\n */\nimport { cloneDeep, find } from 'lodash-es'\n\n// 数组根据函数进行排序\nfunction sortData(data, sortFun) {\n  data.sort(sortFun)\n}\n\n/**\n * 生成排序函数\n * @param {String}  sortField  排序字段\n * @param { Boolean} asc       是否正序\n * @returns {Function}  排序函数\n */\nfunction generateSortFn(sortField, asc) {\n  return (a, b) => {\n    const valueA = a[sortField]\n    const valueB = b[sortField]\n    if (valueA > valueB) {\n      if (asc) {\n        return 1\n      }\n      return -1\n    }\n    if (asc) {\n      return -1\n    }\n    return 1\n  }\n}\n\n/**\n * 数组结构转化成树结构\n * @returns {Array}\n */\nexport const arrayToTree = function (\n  data = [],\n  invalId = [],\n  id = 'id',\n  parentId = 'parentId',\n) {\n  // 结果\n  const result = []\n  // 复制数据\n  const dataTemp = cloneDeep(data)\n\n  dataTemp.forEach((item) => {\n    // 添加children\n    if (!item.children) {\n      item.children = []\n    }\n\n    // 去掉无效节点\n    if (invalId.includes(item[id]))\n      return\n\n    // parentUuid值\n    const parentIdValue = item[parentId]\n\n    // 不存在parent值\n    if (!parentIdValue) {\n      item._level = 1\n      result.push(item)\n    }\n    else {\n      // 父对象\n      const parent = find(dataTemp, node => node[id] === parentIdValue)\n      // 不存在父对象\n      if (!parent) {\n        item._level = 1\n        result.push(item)\n        return\n      }\n      if (!parent.children) {\n        parent._level = parent._level ? parent._level : 1\n        parent.children = []\n      }\n      // 添加到父对象children\n      item._level = parent._level + 1\n      parent.children.push(item)\n    }\n  })\n  return result\n}\n\n/**\n * 查询问题分类路径数据\n * @param {*} id\n * @param {*} data\n */\nexport function arrayTreePathData(id, data) {\n  const item = {\n    problemCategoryLevelId: [],\n    problemCategoryLevelIds: [],\n  }\n  data.forEach((itema) => {\n    itema.children.forEach((itemb) => {\n      itemb.children.forEach((itemc) => {\n        itemc.children.forEach((itemd) => {\n          if (itemd.id === id) {\n            item.problemCategoryLevelIds = [itema.id, itemb.id, itemc.id]\n            item.problemCategoryLevelId = [itema.name, itemb.name, itemc.name]\n          }\n        })\n      })\n    })\n  })\n  return item\n}\n\n/**\n * 对树进行排序(通过自定义函数)\n * @param {Array}  treeData  树\n * @param {Function}  sortFun  排序函数\n * @returns {Array}\n */\nexport const sortTreeByFunction = function (treeData, sortFun) {\n  sortData(treeData, sortFun)\n  treeData.forEach((item) => {\n    const children = item.children\n    if (children && children.length > 0) {\n      sortData(children, sortFun)\n      sortTreeByFunction(children, sortFun)\n    }\n  })\n  return treeData\n}\n\n/**\n * 对树进行排序(通过字段)\n * @param {Array}  treeData  树\n * @param {String}  sortField  排序字段\n * @param { Boolean} asc       是否正序\n * @returns {Array} 排序树\n */\nexport const sortTreeByField = function (treeData, sortField, asc = true) {\n  return sortTreeByFunction(treeData, generateSortFn(sortField, asc))\n}\n\n/**\n * 树的最后一级转化为数组\n * @param {Array}  treeData  树\n * @returns {Array} 数组\n */\nexport const treeFinalToArray = function (treeData) {\n  let result = []\n  Array.from(treeData).forEach((record) => {\n    if (record.childNodes && record.childNodes.length > 0) {\n      const children = treeFinalToArray(record.childNodes)\n      result = result.concat(children)\n    }\n    else {\n      result.push(record.data)\n    }\n  })\n  return result\n}\n\n/**\n * 树转化数组\n * @param {Array}  treeData  树\n * @param {String}  childsKey  树\n * @returns {Array} 数组\n */\nexport const treeToArray = function (treeData = [], childsKey = 'children') {\n  let result = []\n  Array.from(treeData).forEach((record) => {\n    result.push(record)\n    if (record[childsKey] && record[childsKey].length > 0) {\n      const children = treeToArray(record[childsKey], childsKey)\n      result = result.concat(children)\n    }\n  })\n  return result\n}\n\n/**\n * 树对象转化数组\n * @param {Object}  treeObject  树\n * @param {String}  childKey  树\n * @returns {Array} 数组\n */\nexport const treeObjToArray = function (\n  treeObject = {},\n  childKey = 'children',\n) {\n  let result = []\n  result.push(treeObject)\n  if (treeObject[childKey]) {\n    const children = treeObjToArray(treeObject[childKey], childKey)\n    result = result.concat(children)\n  }\n  return result\n}\n\n/**\n* 树数组转多元数组\n*@param { Array } treeData 树\n*@param { Array } path 路径\n*@param { String } childsKey 判断是否为孩子节点key\n*@returns { Array } 数组\n*/\nexport const flattenTree = function (treeData = [], result = [], childsKey = 'children') {\n  treeData.forEach((item) => {\n    const level = item.level;\n    if (!result[level]) {\n      result[level] = [];\n    }\n    result[level].push({ label: item.label, id: item.id, parentId: item.parentId, level: item.level });\n    if (item[childsKey] && item[childsKey].length !== 0) {\n      flattenTree(item[childsKey], result)\n    }\n  })\n  return result\n}\n\n/**\n* 树数组格式化\n*@param { Array } datalist 树\n*@param { Array } propList 属性列表\n*@param { number } level 判断二层还是三层\n*/\nexport const formatTreeOption = function (datalist, propList, level = 2) {\n  let _list = [];\n  datalist.forEach(e => {\n    let obj = {\n      label: e[propList[0]],\n      id: e[propList[1]],\n      level: 0, //数组层级\n      children: [],\n      parentId: 0\n    };\n    let children = [];\n    if (e[propList[4]] && e[propList[4]].length > 0) {\n      e[propList[4]].forEach((c, index) => {\n        if (level == 2) {\n          children.push({\n            label: c[propList[2]],\n            id: c[propList[3]],\n            level: 1,\n            parentId: e[propList[1]]\n          });\n          return 0;\n        }\n        let obj1 = {\n          label: c[propList[2]],\n          id: c[propList[3]],\n          level: 1,\n          parentId: e[propList[1]],\n          children: [],\n        };\n        let children1 = [];\n        if (c[propList[4]] && c[propList[4]].length > 0) {\n          c[propList[4]].forEach(j => {\n            children1.push({\n              label: j[propList[5]],\n              id: j[propList[6]],\n              level: 2,\n              parentId: c[propList[3]]\n            });\n          });\n        }\n        obj1.children = children1;\n        children.push(obj1);\n      });\n    }\n    obj.children = children;\n    _list.push(obj);\n  });\n  return _list;\n}\n\n/**\n* 根据父节点ID过滤\n*@param { Array } data 树\n*@param { String } key 关键字\n*@param { String } keyStr 节点标记\n*/\nexport const filterArray = function (data = [], key, keyStr = 'parentId') {\n  return data.filter(item => {\n    return item[keyStr] == key;\n  })\n}\n\n\nexport const getPickBackFile = function (temp, data, level) {\n  let index = 0;\n  let index1 = 0;\n  let index2 = 0;\n  let arr = [];\n  let arr1 = [];\n  let arr2 = [];\n  let result = {};\n  //匹配对应每列的第几个\n  data.forEach((item, i) => {\n    if (item.id == temp[0]) {\n      index = i;\n      if (level != 1) {\n        item.children.forEach((val, ind) => {\n          if (val.id == temp[1]) {\n            index1 = ind;\n            if (level != 2) {\n              val.children.forEach((e, n) => {\n                if (e.id == temp[2]) {\n                  index2 = n;\n                }\n              });\n            }\n          }\n        });\n      }\n    }\n  });\n  arr = data.map(e => {\n    return { label: e.label, id: e.id, level: 0, parentId: 0 };\n  });\n  result.columns = [arr];\n  result.defaultIndex = [index];\n  if (level != 1) {\n    arr1 = data[index].children.map(e => {\n      return { label: e.label, id: e.id, level: 1, parentId: data[index].id };\n    });\n    result.columns = [arr, arr1];\n    result.defaultIndex = [index, index1];\n    if (level != 2) {\n      arr2 = data[index].children[index1].children.map(e => {\n        return { label: e.label, id: e.id, level: 2, parentId: data[index].children[index1].id };\n      });\n      result.columns = [arr, arr1, arr2];\n      result.defaultIndex = [index, index1, index2];\n    }\n  }\n  return result;\n}\n"],"names":[],"mappings":"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"}